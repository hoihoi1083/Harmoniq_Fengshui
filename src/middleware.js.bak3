import { NextResponse } from "next/server";
import createMiddleware from "next-intl/middleware";
import { getToken } from "next-auth/jwt";
import { routing } from "./i18n/routing";

// Allowed origins for CORS
const allowedOrigins = [
	"https://www.harmoniqfengshui.com",
	"capacitor://localhost",
	"http://localhost:3000",
	"http://localhost:3001",
];

// Create the internationalization middleware
const intlMiddleware = createMiddleware(routing);

export default async function middleware(request) {
	const { pathname } = request.nextUrl;

	// Skip middleware for health check (for AWS load balancer)
	if (pathname === "/api/health") {
		return NextResponse.next();
	}

	// Handle CORS for API routes
	if (pathname.startsWith("/api")) {
		const origin = request.headers.get("origin");

		// Handle preflight OPTIONS request
		if (request.method === "OPTIONS") {
			return new NextResponse(null, {
				status: 200,
				headers: {
					"Access-Control-Allow-Origin": allowedOrigins.includes(
						origin
					)
						? origin
						: allowedOrigins[0],
					"Access-Control-Allow-Methods":
						"GET, POST, PUT, DELETE, OPTIONS",
					"Access-Control-Allow-Headers":
						"Content-Type, Authorization",
					"Access-Control-Max-Age": "86400",
				},
			});
		}

		// Continue with the request and add CORS headers to response
		const response = NextResponse.next();

                // Mobile apps (Capacitor) don't send Origin headers
                // Allow requests without origin OR with allowed origins
                const hasValidOrigin = !origin || allowedOrigins.includes(origin);

		if (hasValidOrigin) {
			response.headers.set("Access-Control-Allow-Origin", origin || allowedOrigins[0]);
			response.headers.set(
				"Access-Control-Allow-Methods",
				"GET, POST, PUT, DELETE, OPTIONS"
			);
			response.headers.set(
				"Access-Control-Allow-Headers",
				"Content-Type, Authorization"
			);
		}

		return response;
	}
	// Skip auth check for public routes
	const isPublicRoute =
		pathname === "/" ||
		pathname === "/zh-TW" || // ðŸ”“ å…è¨±ç¹é«”ä¸­æ–‡é¦–é åŒ¿åè¨ªå•
		pathname === "/zh-CN" || // ðŸ”“ å…è¨±ç°¡é«”ä¸­æ–‡é¦–é åŒ¿åè¨ªå•
		pathname.startsWith("/auth") ||
		pathname.startsWith("/api") ||
		pathname.startsWith("/_next") ||
		pathname.startsWith("/static") ||
		pathname.includes(".") ||
		pathname.includes("/auth/login") ||
		pathname === "/favicon.ico" ||
		pathname.includes("/price") || // æ·»åŠ  price é é¢ç‚ºå…¬å…±è·¯ç”±
		pathname.includes("/customer") || // å…è¨± customer é é¢
		pathname.includes("/free") || // å…è¨± free é é¢
		pathname.includes("/smart-chat2"); // ðŸ”“ å…è¨±åŒ¿åä½¿ç”¨èŠå¤©åŠŸèƒ½

	console.log("ðŸ” Middleware check:", { pathname, isPublicRoute });

	// Handle internationalization first
	const response = intlMiddleware(request);
	// If it's a public route, no need to check authentication
	if (isPublicRoute) {
		console.log("âœ… Public route, allowing access");
		return response;
	}

	// Check if the user is authenticated
	const token = await getToken({
		secureCookie: process.env.NODE_ENV !== "development",
		req: request,
		secret: process.env.NEXTAUTH_SECRET,
	});
	// If not authenticated, redirect to login page
	if (!token) {
		//console.log('pathname', request.nextUrl.pathname);
		const referer = request.headers.get("referer") || "";
		//console.log('request.url', request.nextUrl, referer);
		// // æ£€æŸ¥æ¥æºæ˜¯å¦å·²ç»æ˜¯ç™»å½•é¡µï¼Œé¿å…å¾ªçŽ¯é‡å®šå‘
		if (referer.includes("/auth/login")) {
			return response;
		}
		//å…è®¸ç›®æ ‡é¡µé¢æ˜¯é¦–é¡µã€éšç§æ¡æ¬¾ç­‰é¡µé¢
		if (
			!request.nextUrl.pathname.includes("/design") &&
			!request.nextUrl.pathname.includes("/report")
		) {
			return response;
		}

		const locale = referer.indexOf("zh-CN") >= 0 ? "zh-CN" : "zh-TW";
		// ?callbackUrl=${request.nextUrl.pathname}

		return NextResponse.redirect(
			new URL(
				`/${locale}/auth/login?callbackUrl=${request.nextUrl.pathname}`,
				request.url
			)
		);
	}
	return response;
}

export const config = {
	// Match all paths including API routes
	matcher: ["/((?!_next|.*\\..*|favicon.ico).*)", "/api/:path*"],
};
